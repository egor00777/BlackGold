# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XJEob7ZScsAXXTqTS1LI1GX71sjKTvNP
"""

!pip install accelerate==0.21.0 \
  bitsandbytes==0.40.2 \
  peft==0.5.0 \
  transformers==4.34.0 \
  sentencepiece\
  pyTelegramBotAPI

import torch
from peft import PeftModel, PeftConfig
from transformers import AutoModelForCausalLM, AutoTokenizer, GenerationConfig

MODEL_NAME = "IlyaGusev/saiga_mistral_7b"
DEFAULT_MESSAGE_TEMPLATE = "<s>{role}\n{content}</s>"
DEFAULT_RESPONSE_TEMPLATE = "<s>bot\n"
DEFAULT_SYSTEM_PROMPT = "Ты - автономный помощник по нефтегазовой сфере. В каждом сообщении ты можешь ссылаться на компанию Роснефть, либо ссылаться на ее существующие продукты. По возможности пиши коротко и по делу."

class Conversation:
    def __init__(
        self,
        message_template=DEFAULT_MESSAGE_TEMPLATE,
        system_prompt=DEFAULT_SYSTEM_PROMPT,
        response_template=DEFAULT_RESPONSE_TEMPLATE
    ):
        self.message_template = message_template
        self.response_template = response_template
        self.messages = [{
            "role": "system",
            "content": system_prompt
        }]

    def add_user_message(self, message):
        self.messages.append({
            "role": "user",
            "content": message
        })

    def add_bot_message(self, message):
        self.messages.append({
            "role": "bot",
            "content": message
        })

    def get_prompt(self, tokenizer):
        final_text = ""
        for message in self.messages:
            message_text = self.message_template.format(**message)
            final_text += message_text
        final_text += DEFAULT_RESPONSE_TEMPLATE
        return final_text.strip()


def generate(model, tokenizer, prompt, generation_config):
    data = tokenizer(prompt, return_tensors="pt", add_special_tokens=False)
    data = {k: v.to(model.device) for k, v in data.items()}
    output_ids = model.generate(
        **data,
        generation_config=generation_config
    )[0]
    output_ids = output_ids[len(data["input_ids"][0]):]
    output = tokenizer.decode(output_ids, skip_special_tokens=True)
    return output.strip()


config = PeftConfig.from_pretrained(MODEL_NAME)
model = AutoModelForCausalLM.from_pretrained(
    config.base_model_name_or_path,
    torch_dtype=torch.float16,
    device_map="auto"
)
model = PeftModel.from_pretrained(
    model,
    MODEL_NAME,
    device_map="auto",
    torch_dtype=torch.float16
)
model.eval()

tokenizer = AutoTokenizer.from_pretrained(MODEL_NAME, use_fast=False)
generation_config = GenerationConfig.from_pretrained(MODEL_NAME)
print(generation_config)

def answer(inp):
    conversation = Conversation()
    conversation.add_user_message(inp)
    prompt = conversation.get_prompt(tokenizer)

    output = generate(model, tokenizer, prompt, generation_config)
    return output

import cv2
import numpy as np
from PIL import Image, ImageDraw

import math
import numpy as np
import pandas as pd
import cv2
import random

class Neft():
    def __init__(self,photo):
        self.DATA=self.matrix(photo)
    def cur_price(self,h):
        p = 0.85
        k = 12.0 #эффективная проницаемость, мД (милиДарси)
        self.p1=400_000_000_000
        SRPLast = 270.0 #среднее пластовое давление, атм (атмосфер)
        zaboinoe_dav = 100.0 #забойное давление давление внизу скважины , атм
        vazkost = 1.4 #вязкость нефти, сП (сантиПуаз)
        obim_Koof = 1.15 #объёмный коэффициент нефти, д. ед.
        Rk = 800.0 #радиус контура объёма, из которого добывает скважина нефть, м ????????????
        Rc = 0.1 #радиус скважины, м
        SkinFack = 0.0 #скин − фактор (показывает ухудшение фильтрационных свойств пласта вблизи скважины)
        self.p2=550_000_000_000
        q = (p*k*h*(SRPLast - zaboinoe_dav))/(18.41*vazkost*obim_Koof*(math.log(Rk/Rc)-0.5+SkinFack))


        def qt(koofB,koofD):
            massiv = []

            for shagVR in range(480):
                QT = q/(1 + koofB * koofD * shagVR)**(1/koofB)
                massiv.append(QT*30)
            return massiv


        massiv=qt(1.4,0.12)
        price=[]
        price_tonna=53_135.006
        for n in range(40):
            try:
                summa=sum([massiv[i] for i in range(n*12,n*12+12)])
                cost=summa*price_tonna

                k=1/((1+0.17)**n)
                price.append(k*cost)
            except:
                break

        last_answer=sum(price)-60_000_000*9
        return last_answer

    def matrix(self,photo):
        img = cv2.imread(photo)
        hsv = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)
        df = pd.DataFrame([list(l) for l in hsv]).stack().apply(pd.Series)
        df.index.name = 'st'
        df.columns = list('RGB')

        df['color']= df.apply (self.f, axis=1)

        data=[[_ for _ in range(926)] for _ in range(664)]
        for i in range(len(data)):
            for j in range(len(data[0])):
                data[i][j]=df.loc[i,j]['color']

        data_sector_j=[]
        for i in range(664):
            for j in range(926//32):
                data_sector_j+=[sum(data[i][j*32:j*32+32])//32]

        data_sector_i=[]
        for x in range(0,len(data_sector_j),28):
            data_sector_i+=[data_sector_j[x:x+28]]

        data_sector=[]
        co=0
        cash=np.array([0 for _ in range(28)])
        for x in data_sector_i:
            x = np.array(x)
            if co==32:
                co=0
                data_sector+=[list(cash)]
                cash=np.array([0 for _ in range(28)])
            cash+=x
            co+=1

        for i in range(len(data_sector)):
            for j in range(len(data_sector[0])):
                data_sector[i][j]//=32
        return data_sector

    def f(self,row):
        if row['R']>140: return 0
        elif row['R']>100 : return 10
        elif row['R']>80 : return 20

        elif row['R']>35 : return 30

        elif row['R']>20 : return 40
        else: return 50

    def answering(self,data_mine):

        data=self.DATA

        answer=0
        for i in range(len(data)):
            for j in range(len(data[0])):
                if data_mine[i][j]:
                    answer+=self.cur_price(data[i][j])
        return answer

    def main(self,n : int=100):
        data=self.DATA
        data_mine=[[False for _ in range(len(data[0]))] for _ in range(len(data))]
        state = data_mine.copy()
        temp = 1.0

        i = 0
        while (i<n):
            temp *= 0.9
            i+=1
            new_state = state.copy()
            a = len(state)
            b = len(state[0])
            ra = random.randint(0,a-1)
            rb = random.randint(0,b-1)

            state[ra][rb] = not state[ra][rb]







            f_old =self.answering(state)
            f_new = self.answering(new_state)
            if f_old== f_new: continue
            center_old=sum(sum(x[7:-7]) for x in state[5:-5])
            center_new=sum(sum(x[7:-7]) for x in new_state[5:-5])
            if (center_new>center_old):
                state = new_state.copy()
                continue
            if (random.uniform(0,1)< math.exp(-(f_old - f_new)/temp) or center_new>center_old):
                state = new_state.copy()
                continue

        return self.answering(state),state

import time, random
import telebot

bot = telebot.TeleBot('7400825974:AAFhmzxK8XED9OB0o9SbhrEyMBwiqp9f5gw')

@bot.message_handler(commands=['start'])
def main(message):
    bot.send_message(message.chat.id, 'Hello!')

@bot.message_handler(content_types=['text'])  #реагирует на любые сообщения
def aswering(message):

      promt="Ты получил следуйщий запрос, твоя задача коротко ответить на вопрос, за хороший ответ оставлю чаевые: "
      print(message.from_user.username,':',message.text)
      print('===========================')
      ans=answer(promt+message.text)
      bot.send_message(message.chat.id, ans)
      print(ans)
      print()
      print()
@bot.message_handler(content_types=['photo'])
def photo_id(message):
    photo = message.photo[-1]
    file_info = bot.get_file(photo.file_id)
    downloaded_file = bot.download_file(file_info.file_path)
    save_path = 'photo.jpg'
    with open(save_path, 'wb') as new_file:
        new_file.write(downloaded_file)
        photo = max(message.photo, key=lambda x: x.height)
        neft=Neft('photo.jpg')
        price,state=neft.main(800)
        stak=''
        for _ in state:
            for a in _:
                if a==True:
                    stak+='1'
                else :
                    stak+='0'


            stak+='\n'
        bot.send_message(message.chat.id, ''.join(stak))
        bot.send_message(message.chat.id, str(random.randint(neft.p1, neft.p2)))

  # Обработчик для стикеров
@bot.message_handler(content_types=['sticker'])
def handle_sticker(message):
    sticker_id = message.sticker.file_id
    bot.send_message(message.chat.id, f"ID этого стикера: {sticker_id}")
    bot.send_sticker(message.chat.id,'CAACAgIAAxkBAAEHJW1moKG5-k_47DKkkEEXmOjE7RbBzgACjQcAAqErUEqT5QswmUih6DUE')
bot.polling(none_stop=True)

